==========================
``peak.context`` Internals
==========================

    >>> from peak.context import State, lookup, using, only
    >>> from peak.context import setting, parameter, namespace


Thread testing utility::

    >>> def run_in_thread(func):
    ...     from threading import Thread
    ...     t = Thread(target = func)
    ...     t.start()
    ...     t.join()


State Objects
=============

Separate, ongoing states exist for each thread::

    >>> State.get()
    <...State object at ...>
    
    >>> State.get() is State.get()
    True

    >>> my_state = State.get()
    >>> def test_other_thread():
    ...     print my_state is State.get()
    >>> run_in_thread(test_other_thread)
    False

States allow setting and getting rules for values::

    >>> s = State()
    >>> s[1] = 2
    >>> s[1] = 3

But rules can't be changed once they've been used/read::

    >>> s[1]
    3

    >>> s[1] = 3
    >>> s[1] = 4
    Traceback (most recent call last):
      ...
    RuleConflict: (1, 3, 4)


Settings
========

Settings can be created from functions returning default values::

    >>> def a_setting(): return 42
    >>> a_setting = setting(a_setting)

If a rule isn't established for a setting in a state, its default value is
used::

    >>> s[a_setting]
    42

And of course it can't be changed except to the same value afterward::

    >>> s[a_setting] = 42
    >>> s[a_setting] = 43
    Traceback (most recent call last):
      ...
    RuleConflict: (<function a_setting ...>, 42, 43)


Child States and Setting Inheritance
====================================

States can have child states, that inherit their rules' settings::

    >>> parent = State()
    >>> child = parent.child()
    >>> child.parent is parent
    True

    >>> parent[a_setting] = 99
    >>> child[a_setting]
    99

States can be swapped in and out of current-ness::

    >>> original = State.get()
    >>> old = parent.swap()
    >>> old is original
    True
    >>> State.get() is parent
    True
    >>> old.swap() is parent
    True
    >>> State.get() is old
    True

Calling a setting returns its value in the current state::

    >>> a_setting()
    42

    >>> old = child.swap()
    >>> a_setting()
    99


Parameters and ``lookup``
=========================

Parameters can be created from functions returning values::

    >>> def a_param(): return 42
    >>> a_param = parameter(a_param)

    >>> a_param()
    42

    >>> old = parent.child().swap()
    >>> State.get()[a_param] = object
    >>> a_param()
    <object object at ...>
    >>> o1 = a_param()
    >>> o2 = a_param()
    >>> o1 is o2
    True

The ``lookup()`` function returns the current value for any key, either static
or dynamic::

    >>> lookup(a_param) is a_param()
    True

    >>> lookup(a_setting) is a_setting()
    True

    >>> new = old.swap()

    >>> lookup(a_setting), lookup(a_param)
    (99, 42)


Rule Purity
===========

Looking up non-rule values during default calculation of a rule is forbidden::

    >>> def s2():
    ...     return a_param()
    >>> s2 = setting(s2)
    >>> s2()
    Traceback (most recent call last):
      ...
    DynamicRuleError: ('default rule tried to read dynamic state', ...a_param...)


As is changing the active state::

    >>> def s3():
    ...     return parent.swap()
    >>> s3 = setting(s3)
    >>> s3()
    Traceback (most recent call last):
      ...
    DynamicRuleError: default rule tried to change states

    >>> a_param()
    42


Value Sharing
=============

Computed values should rise to the highest part of the state where they can
be determined to still be based on identical rules::

    >>> root = State()
    >>> s1 = root.child()
    >>> s2 = s1.child()
    >>> s3 = s2.child()
    >>> s4 = s3.child()

    >>> def lookupIn(state, key):
    ...     old = state.swap()
    ...     try: return lookup(key)
    ...     finally: old.swap()

    >>> f1 = lambda:object()
    >>> f2 = object    # similar result, but unequal factory

    >>> k1 = parameter(f1)
    >>> s3[k1] = f2

Looking up k1 in s4 propagates the value to s3 and its children, because the
rule is established there::

    >>> lookupIn(s4, k1) is lookupIn(s3, k1) is lookupIn(s3.child(), k1)
    True

But since s3 has a different rule from s2, the value doesn't propagate any
further up::

    >>> lookupIn(s3, k1) is lookupIn(s2, k1)    # different factories
    False

Instead, s2 shares its value with s1 and root::

    >>> lookupIn(s2, k1) is lookupIn(s1, k1) is lookupIn(root, k1)  # same ones
    True

A value can only be shared as high as the lowest of its (recursive)
dependencies.  So, if we define a new parameter whose factory at the root is
based on a lookup of the previous dynamic parameter::

    >>> k2 = parameter(f1)
    >>> root[k2] = lambda: [k1()]

Then its propagation scope should be the same as those of k1::

    >>> lookupIn(s3, k2) is lookupIn(s2, k2)
    False

    >>> lookupIn(s4, k2) is lookupIn(s3, k2) is lookupIn(s3.child(), k2)
    True

    >>> lookupIn(s4, k2) is not lookupIn(s2, k2)
    True

And a dynamic dependency on k2 should follow the same rules too::

    >>> k9 = parameter(lambda: k2())
    >>> lookupIn(s3, k9) is lookupIn(s2, k9)
    False

The cases shown so far only show dynamic dependency on an already-known value.
We also need to verify dynamic dependency on an as-yet-unknown value::

    >>> k3 = parameter(f1)
    >>> k4 = parameter(f1)
    >>> s2[k3] = object
    >>> root[k4] = lambda: [k3()]

    >>> lookupIn(s3, k4) is lookupIn(s2, k4) is not lookupIn(s1, k4)
    True

And dynamic dependency on a static value::

    >>> k5 = setting(lambda:42)
    >>> k6 = parameter(f1)
    >>> s2[k5] = 99
    >>> root[k6] = lambda: k5()

    >>> lookupIn(s3, k6) is lookupIn(s2, k6) is not lookupIn(s1, k6)
    True





>>> from peak import context

Function Cloning
================

The ``_clonef()`` function makes a new function that "looks like" a source
function (i.e., has the same name, docstring, module, and attributes), but
whose implementation and arguments come from a different function::

    >>> def source_func(x,y,z):
    ...     """The doc is here"""
    ...     return 99
    >>> source_func.a = 99

    >>> help(source_func)
    Help on function source_func:
    <BLANKLINE>
    source_func(x, y, z)
        The doc is here...

    >>> def impl(a,b):
    ...     "foo"
    ...     return 42

    >>> f3 = context._clonef(source_func, impl)

    >>> help(f3)
    Help on function source_func:
    <BLANKLINE>
    source_func(a, b)
        The doc is here...

    >>> f3(1,2)
    42

    >>> f3.a
    99
    >>> source_func.a = 57
    >>> f3.a
    99


Parameter Objects
=================

``@context.parameter`` is a decorator that turns a zero-argument function into
a dynamic variable, whose default value in a new context is the function's
return value when called in that context::

    >>> def my_param():
    ...     """A Parameter"""
    ...     return 42   # default value

    >>> my_param = parameter(my_param)

    >>> help(my_param)
    Help on function my_param...:
    <BLANKLINE>
    my_param(value=NOT_GIVEN)
        A Parameter...

    >>> my_param()
    42

Calling a parameter function with an argument returns a context manager that
temporarily sets the parameter to that value (so you can say, e.g.,
``with my_param(lambda: 99):`` and have it work)::

    >>> cm = my_param(lambda: 99)
    >>> cm.__enter__()
    >>> my_param()
    99
    >>> cm.__exit__(None, None, None)
    >>> my_param()
    42

It should also save the un-computed state of an as-yet-unused parameter::

    >>> def p2():
    ...     print "computing"
    ...     return 69
    >>> p2 = parameter(p2)
    >>> cm = p2(lambda: 57)
    >>> cm.__enter__()
    >>> p2()
    57
    >>> cm.__exit__(None, None, None)
    >>> p2()
    computing
    69



Services
========

    >>> class S1(context.Service): pass
    >>> class S2(context.Service): context.replaces(S1)

    >>> S1.get is S2.get
    True

    >>> S1.get() is S2.get()
    True

    >>> s1 = S1.get()
    >>> type(s1)
    <class 'S1'>

    >>> s2 = S2()
    >>> s2.__enter__()
    >>> s2 is S1.get() is S2.get()
    True
    >>> s2.__exit__(None,None,None)
    >>> s1 is S1.get()
    True

The ``__default__()`` classmethod of a service is called to create its default
instance in a given context::

    >>> class S3(context.Service):
    ...     def __default__(cls):
    ...         print "creating default instance of", cls
    ...         return cls()
    ...     __default__ = classmethod(__default__)

    >>> s3 = S3.get()
    creating default instance of <class 'S3'>

``context.replaces()`` can only be called inside a ``context.Service`` subclass
definition, and only once::

    >>> context.replaces(S1)
    Traceback (most recent call last):
      ...
    SyntaxError: Class decorators may only be used inside a class statement

    >>> class X:
    ...     context.replaces(S1)
    Traceback (most recent call last):
      ...
    TypeError: context.replaces() can only be used in a context.Service subclass

    >>> class X(context.Service):   # doctest: +NORMALIZE_WHITESPACE
    ...     context.replaces(S1)
    ...     context.replaces(S3)
    Traceback (most recent call last):
      ...
    ValueError: replaces() must be used only once per class; there is already a
    value for ``get``: <bound method ...lookup of <class 'S1'>>

Services should be subclassable and super() should be usable in spite of all
the singleton-izing magic, for both instance and class methods::

    >>> class Base(context.Service):
    ...     def test(self, other=None):
    ...         print "hello from Base"
    ...         if other is not None and other is not self:
    ...             print "insanity!"
    ...     t2 = classmethod(test)

    >>> class Sub(Base):
    ...     def test(self):
    ...         print "hello from sub"
    ...         super(Sub, self).test(self)
    ...     def t2(cls):
    ...         print "hello from sub cm"
    ...         super(Sub, cls).t2()
    ...     t2 = classmethod(t2)

    >>> Base.get() is Sub.get()
    False
    
    >>> Sub.test()
    hello from sub
    hello from Base

    >>> Sub.t2()
    hello from sub cm
    hello from Base

Service attributes should be settable and deletable, mapped to the instance::

    >>> class Dummy(context.Service):
    ...     foo = 42

    >>> Dummy.foo
    42

    >>> Dummy.foo = 99
    >>> Dummy().foo
    42

    >>> Dummy.get().foo
    99

    >>> del Dummy.foo
    >>> Dummy.foo
    42
    >>> Dummy.get().foo
    42



    

Namespaces
==========

    >>> def aSetting(): pass
    >>> aSetting = setting(aSetting)

    >>> ns1 = namespace(aSetting)
    >>> ns1['foo']
    <function aSetting.foo ...>

    >>> foo = ns1['foo']
    >>> foo is ns1['foo']
    True

    >>> foo.bar
    <function aSetting.foo.bar ...>
    >>> foo.bar is foo['bar']
    True

    >>> 'spam' in foo
    False

    >>> 'bar' in foo
    True

    >>> list(foo)
    ['bar']

    >>> foo.bar.spam is foo['bar.spam']
    True

    >>> 'bar.spam' in foo
    True

    >>> def handler(inherit, key):
    ...     print "looking up", key
    ...     return key.__name__

    >>> State.get()[foo['*']] = handler

    >>> foo.baz()
    looking up <function aSetting.foo.baz ...>
    'aSetting.foo.baz'

    >>> foo.bar.bang()  # 2nd level rule lookup
    looking up <function aSetting.foo.bar.bang ...>
    'aSetting.foo.bar.bang'

    >>> print ns1.whee()  # aSetting returns nothing, so so does this
    None

    >>> foo['really.really.long.name.needing.multiple.rules']()
    looking up ...foo.really.really.long.name.needing.multiple.rules ...
    'aSetting.foo.really.really.long.name.needing.multiple.rules'

    >>> sorted(foo)
    ['bar', 'baz', 'really']


Actions
=======

    >>> print context.Action.get()
    Traceback (most recent call last):
      ...
    RuntimeError: No Action is currently active

    >>> act = context.Action()

    >>> class TestResource(object):
    ...     def __enter__(self):
    ...         print "Setting up"
    ...         return self
    ...     def __exit__(self, typ, val, tb):
    ...         print "Tearing down", map(str,(typ,val,tb))

    >>> res = context.resource(lambda: TestResource())

    >>> res()
    Traceback (most recent call last):
      ...
    RuntimeError: No Action is currently active

    >>> act.__enter__()
    >>> context.Action.get() is act
    True

    >>> act.__enter__()
    Traceback (most recent call last):
      ...
    RuntimeError: Action is already in use

    >>> r1 = res()
    Setting up

    >>> r1
    <TestResource object...>

    >>> r2 = res()
    >>> r1 is r2
    True

    >>> act.__exit__(None,None,None)
    Tearing down ['None', 'None', 'None']

    >>> print context.Action.get()
    Traceback (most recent call last):
      ...
    RuntimeError: No Action is currently active

    >>> act.__exit__(None,None,None)
    Traceback (most recent call last):
      ...
    RuntimeError: Action is not currently in use

    >>> act.__enter__()
    >>> res()
    Setting up
    <TestResource object...>

    >>> r3 = res()
    >>> r4 = res()
    >>> r3 is r4
    True
    >>> r3 is r2
    False

    >>> act.__exit__(TypeError,TypeError("Foo"),None)
    Tearing down [...'exceptions.TypeError'..., 'Foo', 'None']

    >>> def my_factory():
    ...     print "Factory running"
    ...     return 42

    >>> act = context.Action()
    >>> act.__enter__()
    >>> State.get()[res] = my_factory

    >>> res()
    Factory running
    42
    >>> res()
    42

    >>> class Failure(object):
    ...     def __enter__(self): raise RuntimeError("Foo!")
    ...     def __exit__(self,*exc):
    ...         raise AssertionError("This shouldn't get called!")

    >>> res2 = context.resource(lambda: Failure())
    >>> res2()
    Traceback (most recent call last):
      ...
    RuntimeError: Foo!

    >>> class Success(object):
    ...     def __enter__(self):
    ...         print "entering"    
    ...         return 99
    ...     def __exit__(self, *exc):
    ...         print "exiting", exc

    >>> res3 = context.resource(lambda: Success())
    >>> res3()
    entering
    99
    >>> act.__exit__(None,None,None)  # no __exit__ for failed __enter__
    exiting (None, None, None)


Source Lines
============

    >>> from peak.context import Source, Line
    
    >>> s = Source("<test>", "def foo():\n  def bar(): return 42\n  return bar")
    >>> s
    Source('<test>')

    >>> list(s)
    ['def foo():\n', '  def bar(): return 42\n', '  return bar']

    >>> exec s.compile('exec')
    >>> bar = foo()
    >>> bar.func_code.co_firstlineno
    2

    >>> s[1].strip()
    'def bar(): return 42'

    >>> _.line
    2

    >>> (s[1]+'\n').splitlines()[1].line
    3
    
    >>> exec(s[1].strip().compile('exec'))
    >>> bar.func_code.co_firstlineno
    2

    >>> l = Line("lambda: (\n lambda: \n lambda: 42)", s, 19)
    >>> f = eval(l.compile('eval'))
    >>> f.func_code.co_firstlineno
    19
    >>> f().func_code.co_firstlineno
    20
    >>> f()().func_code.co_firstlineno
    21
    >>> f()()()
    42

    >>> from pkg_resources import yield_lines
    >>> list(yield_lines(s))
    ['def foo():', 'def bar(): return 42', 'return bar']

    >>> _[2].line
    3


PEP 343 Implementation Tests
============================

An example context manager::

    >>> def demo_manager(value):
    ...     print "before"
    ...
    ...     try:
    ...         yield value
    ...         context.reraise()   # propagate error, if any
    ...     except TypeError, exc:
    ...         print "caught TypeError"
    ...     print "after"
    >>> demo_manager = context.manager(demo_manager)

Applied to a simple function using ``with_()``::

    >>> def something(ob):
    ...     print "got", ob
    ...     return 42
    >>> context.with_(demo_manager(99), something)
    before
    got 99
    after
    42

Errors in the called function get passed to ``__exit__()`` and reraised::

    >>> def fail(v):
    ...     raise TypeError("foo")

    >>> context.with_(demo_manager(57), fail)
    before
    caught TypeError
    after

    >>> def fail(v):
    ...     raise KeyError("foo")
    >>> try:
    ...     print context.with_(demo_manager(57), fail)
    ... except KeyError:
    ...     print "KeyError escaped!"
    before
    KeyError escaped!

You don't have to decorate a new function to use ``call_with`` or ``with_()``::

    >>> def something(ob):
    ...     print "got", ob
    ...     return 42

Just wrap the context object, then pass the result the function to call::

    >>> context.call_with(demo_manager(None))(something)
    before
    got None
    after
    42

Or use ``with_()``, passing in the context and the function in one call::

    >>> context.with_(demo_manager(None),something)
    before
    got None
    after
    42

Finally, notice that ``__enter__`` may return a different object, which will be
passed in to the called function as its sole argument::

    >>> context.call_with(demo_manager(99))(something)
    before
    got 99
    after
    42

    >>> context.with_(demo_manager(99),something)
    before
    got 99
    after
    42

